---
title: "07_functions_2"
author: "JR"
date: "8/1/2022"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(stringsAsFactors = F)
library(GenomicRanges)
library(tidyverse)
library(IRanges)
source("../util/BCHM5631_my_class_functions.R") #needed to delete and extra ../ because wasnt up/down from file- based on what you set your working directory should set to utl where this function is-  or can copy full path take out ../ part and put the file name 
# setting file paths
basepath <- "/scratch/Shares/rinnclass/CLASS_2023"
peak_path <- "2023_2_10_group3/group/results/bwa/mergedLibrary/macs/broadPeak/"
broadpeakfilepath <- file.path(basepath, peak_path)
```

# interesect peaks custom function
In the previous class we created a function to import peak files as a GRanges.
We can now use this to find overlaps in replicates using another function
"intersect peaks" Let's take a look at our "intersect_peaks" function. 


Let's first run import_peaks 

```{r import peaks}
# import peaks to get peak_list
peak_list <- import_peaks(consensus_file_path = broadpeakfilepath)
# This will be the input into our intersect_peaks function
# quick check of peak numbers per file
num_peaks <- sapply(peak_list, length)  # tell what object what to work over- wants data and what parameter
num_peaks # num of peaks in each protein 
# NOTE: I am removing replicate 1 and 3 from K27me3 -- far fewer peaks than the other files 
# NOTE removing REST replicate 3 as well
```

Now that we have a named list of GRanges for each peak file 
We can export them as consensus peak files


Now let's create consensus peaks where all peaks overlap 
!! This function will be very useful moving forward and run in 1 line !!
Hang in there it's worth it.

```{r consensus peaks function}
# import peaks as named GRange list
# peak_list <- import_peaks(consensus_file_path = broadpeakfilepath)
# getting dbp name as object -- problem is rep number won't work
# we need a unique DBP name with out the replicate as input to for loop
names(peak_list)
# let's use unlist(strsplit) on names to get a unique name for each DBP- want unique name for 4 loop to go thru all replicates of that name- example tell for loop CEBBPZ will run all replicates  
dbps <- unique(sapply(names(peak_list), function(x) {
   unlist(strsplit(x, "_"))[1]    # split the string on first underscore take the left side- cutting out replicate number- will just have the 5 names of the proteins, unique just gives you the answer one time  
}))
dbps
``` 

# Now let's make the consensus_from_reduced function !
The parameters are peak_list and dbp which will be made in the funtion

```{r consensus peaks function}
# Now we can make a function to find peaks in all samples!!
# setting up function and parameters (dbp and peak_list) 
#order of files first +second matter when do overlaps
#make matrix- if any overlap get a 1, no overlap=0 sum the row of all peaks total- this is master list of peaks then figure out what goes in what file- if in file 1 gets a 1 if not in a file gets 0, ex: if in file 2 gets a 1 if not gets a 0, makes this reproducible bc have universal list and then going back to figure out what files they belong too if sum of row = number of replicates- then peak is in every file(file=different replicates)
consensus_from_reduced <- function(dbps, peak_list) { # knows unique name of dbp out of all the peak list- so its grabbing the replicates
  
# index into list of Granges for each replicate for each dbp: dbp looks like:
  # grep instead of string split for dbp name in peak list
  # as character- to read for letters
  dbp_peaks <- peak_list[grepl(as.character(dbps), names(peak_list))]
  
  # this will unlist the Granges for each of the dbps "unlist"
  # This makes a list of all the peaks in all the file and takes union of overlaps
  # note making a list of all peaks in any replicate - then count how many times peak shows up (below)
  suppressWarnings(all_peaks <- GenomicRanges::reduce(unlist(as(dbp_peaks, "GRangesList"))))# if you don't put this you'll get too many annoying warnings, telling it it is a grange list 
  #unlist takes list of all peak replicates and unlists to separate out each g range separately
  
  # Make a matrix of all peaks (rows) and the cols will be the replicate for each DBP
  
  # let's see what we need to do to make a matrix
  # ?matrix- Na makes it empty, just telling R making a maxtrix, rows= # sum total peaks in all files(replicates) , length dbp peaks= # of replicate files  
  peak_exists <- matrix(NA, nrow = length(all_peaks), ncol = length(dbp_peaks))
  
  # for loop to "countOverlaps" for each replicate
  for(i in 1:length(dbp_peaks)) {
    
    # indexing into peak_exists -- all rows and ith col 
    # this is then populated with overlaps, putting in columns 1 or 0, counting peaks between all peaks the master and then where it came from- (which replicate file came from) 
    suppressWarnings(peak_exists[,i] <- as.numeric(countOverlaps(all_peaks, dbp_peaks[[i]]) > 0))
  }
  
  # filter to consensus requiring peaks to be in all replicates
  # row sum of peak exist has to be greater than nDBPs and thus n enteries in peak exists
  dbp_consensus <- all_peaks[rowSums(peak_exists) == ncol(peak_exists)]
  # if peak is in all replicates- sum of the row should = the number of replicates(aka columns) example- 6 replicates sum of row = 5, peak is in 5/6 replicate files 
  # Required only two replicates
  # dbp_consensus <- all_peaks[rowSums(peak_exists) > 1] # can change this 1 to be greater to see how many peaks are in every replicate- here we are saying tell us all the ones that have a row of sum 1 or more
  return(dbp_consensus) # peaks that exist in all replicates 
}
```

# Nice we have a function we can use in lapply (kinda like forloop) across each file
Note we are using dbps as input of unique dbp a required parameter.

```{r consensus peaks function}
# getting dbp input as dbps
dbps <- unique(sapply(names(peak_list), function(x) {
   unlist(strsplit(x, "_"))[1]
}))
# Now run consensus_from_reduced on peak_list
# parameters: dbps (unique dbp names, function = consensu_from_reduced, peaks_list of Granges)
# TODO : for loop is not grepping right - exact same code as function????
```

Let's make the function
```{r}
#' CREATE CONSENSUS PEAKS
#' this function will take multiple replicate .broadPeak files (also narrow)
#' find peaks that overlap in all the replicates. 
#' @description 
#' input set of chipseq replicate peak files
#' this function then creates one merged file peaks in all samples
#' @param dbp
#' This will be extracted with names(GR_list) in the lapply at end of fun
#' You will need a "dbps" or some object for the lapply that has the 
#' name of each dbp in the named GRanges list
#' 
#' @param peak_list
#' Named list of GRanges for each chipseq replicate
#' peak_list can be generated using import_peaks function above
consensus_from_reduced <- function(dbp, peak_list) {
  dbp_peaks <- peak_list[grepl(as.character(dbp), names(peak_list))]
  suppressWarnings(all_peaks <- GenomicRanges::reduce(unlist(as(dbp_peaks, "GRangesList"))))
  all_peaks <- all_peaks[grepl("chr", seqnames(all_peaks))] # taking out anything that doesnt have chr
  
  # peak_exists <- lapply(dbp_peaks, function(x) {
  #   as.numeric(countOverlaps(all_peaks, x) > 0))
  # }) %>%
  # bind_rows() OR bind_cols()
  peak_exists <- matrix(NA, nrow = length(all_peaks), ncol = length(dbp_peaks))
  for(i in 1:length(dbp_peaks)) {
    suppressWarnings(peak_exists[,i] <- as.numeric(countOverlaps(all_peaks, dbp_peaks[[i]]) > 0))
  }
# filter to consensus requiring peaks to be in all replicates
dbp_consensus <- all_peaks[rowSums(peak_exists) == ncol(peak_exists)]
# Required only two replicates == dbp_consensus <- all_peaks[rowSums(peak_exists) > 1]
return(dbp_consensus)
}
```

# Now running the function consensus_from_reduced

```{r running function}
# loading peak list
peak_list <- import_peaks(consensus_file_path = broadpeakfilepath)
# getting dbp input as dbps
dbps <- unique(sapply(names(peak_list), function(x) {
   unlist(strsplit(x, "_"))[1]
}))
# Let's run it !
consensus_list <- lapply(dbps, consensus_from_reduced, peak_list) # think of lapply as another for loop to run all of the proteins 
# adding names to results
names(consensus_list) <- dbps # need to name consensus list 
sapply(consensus_list, length) # looking out length now of peaks that overlap- make sure not all the same number
# try sapply, lapply and if one doesn't work try the other 
```


NOW LET'S Make this a FUNction -- in our util/my_class_function.R 
Very useful and who would want to code that again :)

# CONGRATUALTIONS we have finished 04_R_basics !
# We will now move to 05_R_analyses and work on the custom data set you chose!

We are now equipped with some data and functions to explore Genome Biology!
Moving fowrard we will start analyzing the data -- Let's GO !

























---
title: "07_functions_2"
author: "JR"
date: "8/1/2022"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(stringsAsFactors = F)
library(GenomicRanges)
library(tidyverse)
library(IRanges)
source("../../util/my_class_functions.R")


# setting file paths
basepath <- "/scratch/Shares/rinnclass/CLASS_2023/JR"
peak_path <- "CLASS_2023/CLASSES/03_Nextflow/00_my_chipseq/results/bwa/mergedLibrary/macs/broadPeak/"
broadpeakfilepath <- file.path(basepath, peak_path)

```

# interesect peaks custom function
In the previous class we created a function to import peak files as a GRanges.
We can now use this to find overlaps in replicates using another function
"intersect peaks" Let's take a look at our "intersect_peaks" function. 


Let's first run import_peaks 

```{r import peaks}

# import peaks to get peak_list
peak_list <- import_peaks(consensus_file_path = broadpeakfilepath)
# This will be the input into our intersect_peaks function

# quick check of peak numbers per file
num_peaks <- sapply(peak_list, length) 
num_peaks


# NOTE: I am removing replicate 1 and 3 from K27me3 -- far fewer peaks than the other files 
# NOTE removing REST replicate 3 as well
```

Now that we have a named list of GRanges for each peak file 
We can export them as consensus peak files


Now let's create consensus peaks where all peaks overlap 
!! This function will be very useful moving forward and run in 1 line !!
Hang in there it's worth it.

```{r consensus peaks function}
# import peaks as named GRange list
# peak_list <- import_peaks(consensus_file_path = broadpeakfilepath)

# getting dbp name as object -- problem is rep number won't work
# we need a unique DBP name with out the replicate as input to for loop
names(peak_list)

# let's use unlist(strsplit) on names to get a unique name for each DBP
dbps <- unique(sapply(names(peak_list), function(x) {
   unlist(strsplit(x, "_"))[1]
}))

```

# Now let's make the consensus_from_reduced function !
The parameters are peak_list and dbp which will be made in the funtion

```{r consensus peaks function}

# Now we can make a function to find peaks in all samples!!
# setting up function and parameters (dbp and peak_list)
consensus_from_reduced <- function(dbp, peak_list) {
  
# index into list of Granges for each replicate for each dbp: dbp looks like:
dbps
  # grep instead of string split for dbp name in peak list
  dbp_peaks <- peak_list[grepl(as.character(dbps), names(peak_list))]
  
  # this will unlist the Granges for each of the dbps "unlist"
  # This makes a list of all the peaks in all the file and takes union of overlaps
  # note making a list of all peaks in any replicate - then count how many times peak shows up (below)
  suppressWarnings(all_peaks <- GenomicRanges::reduce(unlist(as(dbp_peaks, "GRangesList"))))
  
  # Make a matrix of all peaks and the cols will be the replicate for each DBP
  peak_exists <- matrix(NA, nrow = length(all_peaks), ncol = length(dbp_peaks))
  
  # for loop to "countOverlaps" for each replicate
  for(i in 1:length(dbp_peaks)) {
    
    # indexing into peak_exists -- all rows and ith col 
    # this is then populated with overlaps
    suppressWarnings(peak_exists[,i] <- as.numeric(countOverlaps(all_peaks, dbp_peaks[[i]]) > 0))
  }
  
  # filter to consensus requiring peaks to be in all replicates
  # row sum of peak exist has to be greater than nDBPs and thus n enteries in peak exists
  dbp_consensus <- all_peaks[rowSums(peak_exists) == ncol(peak_exists)]
  # Required only two replicates
  # dbp_consensus <- all_peaks[rowSums(peak_exists) > 1]
  return(dbp_consensus)
}
```

# Nice we have a function we can use in lapply (kinda like forloop) across each file
Note we are using dbps as input of unique dbp a required parameter.

To refresh: this code that splits "DBP_1" into DBP and 1 takes just dbp value [1]
dbps <- unique(sapply(names(peak_list), function(x) {
   unlist(strsplit(x, "_"))[1]
}))


```{r consensus peaks function}

# getting dbp input as dbps
dbps <- unique(sapply(names(peak_list), function(x) {
   unlist(strsplit(x, "_"))[1]
}))

# Now run consensus_from_reduced on peak_list
# parameters: dbps (unique dbp names, function = consensu_from_reduced, peaks_list of Granges)
consensus_list <- lapply(dbps, consensus_from_reduced, peak_list)

# adding names to results
names(consensus_list) <- dbps

```

NOW LET'S Make this a FUNction -- in our util/my_class_function.R 
Very useful and who would want to code that again :)

# CONGRATUALTIONS we have finished 04_R_basics !
# We will now move to 05_R_analyses and work on the custom data set you chose!

We are now equipped with some data and functions to explore Genome Biology!
Moving fowrard we will start analyzing the data -- Let's GO !



